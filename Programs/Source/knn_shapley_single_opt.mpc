from Compiler.library import *
from Compiler import mpc_math
from Compiler.types import MultiArray
import copy

program.use_edabit(True)
# spdz2k中不能使用
# program.use_split(4)

# 训练数据量
T_NUM = 3
# 验证数据量
V_NUM = 4
# 特征数量
F_NUM = 3
# 有效位
V_LEN = 16
# 浮点数整数形式的有效位
V_LEN_SFIX = V_LEN + sfix.f

K = 2

def copy_array_2d(a):
    b = a.same_shape()
    @for_range(len(a))
    def f(i):
        b[i] = Array.create_from(a[i])
    return b


def secure_perm_inv(sp, v):

    sp_copy = Array.create_from(sp)
    v_copy = Array.create_from(v)

    shuffle = sint.get_secure_shuffle(T_NUM)
    sp_copy.secure_permute(shuffle)
    v_copy.secure_permute(shuffle)
    plain_sp = sp_copy.reveal()
    v_copy.permute(plain_sp, reverse=True)
    return v_copy

def secure_perm(sp, v):

    sp_copy = Array.create_from(sp)
    v_copy = Array.create_from(v)

    shuffle = sint.get_secure_shuffle(T_NUM)
    sp_copy.secure_permute(shuffle)
    plain_sp = sp_copy.reveal()
    v_copy.permute(plain_sp)
    v_copy.secure_permute(shuffle, reverse=True)
    return v_copy

def print_array_3d(x, len1, len2,len3):
    @for_range(len1)
    def f(i):
        @for_range(len2)
        def g(j):
            values = [x[i][j][k].reveal() for k in range(len3)]
            print_ln('x[%s][%s][:] = %s', i, j, values)

def print_array_2d(x, len1, len2):
    @for_range(len1)
    def f(i):
        values = [x[i][k].reveal() for k in range(len2)]
        print_ln('x[%s][:] = %s', i, values)

def print_array(x, len1):
    values = [x[k].reveal() for k in range(len1)]
    print_ln('x[:] = %s',  values)

def sfix_to_sint(a):
    return a.v
def sint_to_sfix(a):
    return a / (1 << sint(sfix.f))

def bit_concat(a, b, bit_length_a, bit_length_b):
    # return sint(0)
    a_bits = a.bit_decompose(bit_length_a)
    b_bits = b.bit_decompose(bit_length_b)
    c_bits = a_bits + b_bits
    return sint.bit_compose(c_bits)

def bit_split(x, bit_length_a, bit_length_b):
    # return sint(0), sint(0)
    length = bit_length_a + bit_length_b
    x_bits = x.bit_decompose(length)
    bits_a = [x_bits[i] for i in range(bit_length_a)]

    bits_b = [x_bits[i] for i in range(bit_length_a, bit_length_a + bit_length_b)]
    return sint.bit_compose(bits_a),sint.bit_compose(bits_b)

# 验证函数
def test(actual, expected):
    # you can reveal a number in order to print it

    actual = actual.reveal()
    print_ln('expected %s, got %s', expected, actual)

# 定义计算距离的函数
def dist(v1, v2, length):
    # 初始化差值
    sum_of_squares = sfix(0)
    # 计算向量差的平方和
    for i in range(length):
        diff = v1[i] - v2[i]
        sum_of_squares += diff * diff
    # 计算平方根
    # distance = mpc_math.sqrt(sum_of_squares)
    # return distance
    return sum_of_squares

# 输入数据。暂时定义为，3个参与方 每方只有一条数据，包括3个特征
x_train = MultiArray([T_NUM, F_NUM], sfix)
y_train = Array(T_NUM, sint)
y_train.alloc()

# party0 input
@for_range(F_NUM)
def f(i):
    x_train[0][i] = sfix.get_input_from(0)
y_train[0] = sint.get_input_from(0)

# party1 input
@for_range(F_NUM)
def f(i):
    x_train[1][i] = sfix.get_input_from(1)
y_train[1] = sint.get_input_from(1)

# party2 input
@for_range(F_NUM)
def f(i):
    x_train[2][i] = sfix.get_input_from(2)
y_train[2] = sint.get_input_from(2)

# party3 input
# @for_range(F_NUM)
# def f(i):
#     x_train[3][i] = sfix.get_input_from(3)
# y_train[3] = sint.get_input_from(3)

# party4 (buyer) input 两条数据*3个特征=6
x_valid = MultiArray([V_NUM,F_NUM], sfix)
y_valid = Array(V_NUM, sfix)
@for_range(V_NUM)
def f(i):
    @for_range(F_NUM)
    def g(j):
        x_valid[i][j] = sfix.get_input_from(3)
@for_range(V_NUM)
def f(i):
    y_valid[i] = sint.get_input_from(3)


# 对于每个valid数据都计算距离
dists = MultiArray([V_NUM,T_NUM], sfix)
@for_range(V_NUM)
def f(i):
    @for_range(T_NUM)
    def g(j):
        dists[i][j] = dist(x_train[j], x_valid[i], F_NUM)
        print_ln('dist: %s', dists[i][j].reveal())


to_be_sorted = MultiArray([V_NUM, T_NUM], sint)

print_ln("original dist")
print_array_2d(dists, V_NUM, T_NUM)
@for_range(V_NUM)
def f(i):
    @for_range(T_NUM)
    def g(j):

        to_be_sorted[i][j] =sfix_to_sint(dists[i][j])

# 计算排序
print_ln("begin sorting")
permutation = MultiArray([V_NUM, T_NUM], sint)
@for_range_opt(V_NUM)
def f(i):
    permutation[i] = to_be_sorted[i].sort_perm()
print_ln("end sorting")

print_ln("after split, permutation")
print_array_2d(permutation, V_NUM, T_NUM)

# 应用permutation到y
print_ln("before permute, y_train")
print_array(y_train, T_NUM)
print_ln("before permute, permutation")
print_array_2d(permutation, V_NUM, T_NUM)

permuted_y = MultiArray([V_NUM, T_NUM], sint)
@for_range(V_NUM)
def f(i):
    permuted_y[i] = secure_perm(permutation[i], y_train)

print_ln("after permute, permuted_y")
print_array_2d(permuted_y, V_NUM, T_NUM)

# 计算shapley
shapley = MultiArray([V_NUM, T_NUM], sfix)
equality = MultiArray([V_NUM, T_NUM], sfix)

@for_range(V_NUM)
def f(i):
    # 计算第n个值的shapley
    shapley[i][T_NUM - 1] = (permuted_y[i][T_NUM - 1] == y_valid[i]) / T_NUM
    equality[i][T_NUM - 1] = (permuted_y[i][T_NUM - 1] == y_valid[i])
    # 计算剩余n-1个值的shapley
    @for_range(T_NUM - 1)
    def g(j):
        current_index = T_NUM - 2 - j
        nomi1 = (permuted_y[i][current_index] == y_valid[i]) - (permuted_y[i][current_index + 1] == y_valid[i])
        equality[i][current_index] = nomi1
        nomi2 = (K < current_index).if_else(K, current_index + 1)
        deno = K * (current_index + 1)
        shapley[i][current_index] = shapley[i][current_index + 1] + (nomi1 * nomi2) / (deno)

@for_range(V_NUM)
def f(i):
    shapley[i] = secure_perm_inv(permutation[i], shapley[i])
    equality[i] = secure_perm_inv(permutation[i], equality[i])


print_ln("shapley")
print_array_2d(shapley, V_NUM, T_NUM)
print_ln("permuted equality")
print_array_2d(equality, V_NUM, T_NUM)

avg_shapley = Array(T_NUM, sfix)
@for_range(T_NUM)
def f(i):
    @for_range(V_NUM)
    def g(j):
        avg_shapley[i] += shapley[j][i]
    avg_shapley[i] = avg_shapley[i] / V_NUM

print_ln("avg_shapley")
print_array(avg_shapley,T_NUM)


